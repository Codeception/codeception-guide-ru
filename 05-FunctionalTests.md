# Функциональное тестирование

Теперь, когда мы имеем написанные приемочные тсты, настало врмя рассмотреть фнукциональные тесты, функциональные тесты, это почти то же самое что и приемочные, однако есть одно существенное различие: Функциональные тесты не требуют использовния веб сервера для запуска своих сценариев. Другими словами мы будем запускать наше приложение внутри тестов, имитируя запросы и ответы.

Говоря простыми словами, мы устанавливаем переменные `$_REQUEST`, `$_GET` и `$_POST`, затем выполняем скрипт внутри тестаполучаем ответ и тестируем все это.
Функциональное тестирование часто может быть более лучшим реением чем приемочное потоку как такие тесты не требуют использования веб сервера и могут предложить более подробный отладочный вывод. К примеру, если ваш сайт выбросит исключение, оно будет напечатано в консоли.

Codeception может подключатся к различным веб фреймворкам поддерживающим функциональное тестирование. К примеру вы можете запустить функциональные тесты для приложения построенного поверх Zend Framework, Symfony или Symfony2 используя лишь модули поставляемые Codeception! Список поддерживаемых модулей будет разобран позже.

Модули для всех этих фреймворков имеют одинаковый интерфейс, поэтому ваши тесты не будут связханы друг с другом. Вот простой пример функционального теста.

``` php
<?php
$I = new TestGuy($scenario);
$I->amOnPage('/');
$I->click('Login');
$I->fillField('Username','Miles');
$I->fillField('Password','Davis');
$I->click('Enter');
$I->see('Hello, Miles', 'h1');
// $I->seeEmailIsSent() - special for Symfony2
?>
```

Такой же тест как и приемочный. Как видите можно использовать одинаковые методы и для приемочных и для функциональных тестов.
Мы рекомендуем тестировать нестабильные части приложения с помощью функциональных тестов, а стабильные с помощью приемочных.

## Ловушки

Приемочные тесты обычно намного медленнее, чем функциональные. Однако функциональные тесты менее стабильны и запускают тестовый фреймворк и приложение в одном окружении.

#### Headers, Cookies, Sessions

Одна из исзестных проблем функциональных тестов, использование PHP функций работающих с переменными из категории `headers`, `sessions`, `cookies`.
Как вы знаете, функция `header` возвратит ошибку, если будет выполнена более одного раза. В функциональных тестах мы запускаем наше приложение несколько раз, таким образом мы получим много ненужных ошибок при отображении результатов.

#### Разделяемая память

При функциональном тестировании в отличие от традиционного,  приложение PHP не останавливается после выполнения запроса.
Так как все запросы выполняются в одном контейнере памяти они не изолированны.
Таким образом **если вы заметили что ваши тесты магическим образом падают, однако не должны - попробуйте выполнить один тест.**
Это проверит изолированны ли тесты во время работы. Потому что довольно просто поломать окружение когда все тесты выполняются в разделяемой памяти.
Держите ваши память в чистоте, избегайте утечек памяти и очищайте глобальные и статические переменные.

## Основы функционального тестирования

Ваши функциональные тесты распологаются в каталоге `tests/functional`.
Для начала вам необходимо включить один из модулей фреймворков в конфигурационный файл тестового набора: `tests/functional.suite.yml`.
Примеры конфигурации фреймворков описаны ниже в данной главе.

После вам необходимо пересобрать Guy-классы

```
php codecept.phar build
```

Для генерации теста вы можете использовать стандартную команду генератор `generate:cept`:

```
php codecept.phar generate:cept functional myFirstFunctional
```

После чего выполнить тесты с помощью `run`:

```
php codecept.phar run functional
```

Используйте опцию `--debug` для более детального вывода.

## Сообщения об ошибках

По умолчанию Codeception использует значенич `E_ALL & ~E_STRICT & ~E_DEPRECATED`. 
В функциональных тестах вы можете захотеть сменить эти значения в зависимости от используемого фреймворка.
Сообщения об ошибках могут быть настроены в конфигурационном файле набора:

{% highlight yaml %}
class_name: TestGuy
modules:
    enabled: [Yii1, TestHelper]
error_level: "E_ALL & ~E_STRICT & ~E_DEPRECATED"
{% endhighlight %}

`error_level` может быть установлен глобально в файле `codeception.yml`.

## Фреймворки

Codeception интегрирован с большинством популярных PHP фреймворков.
Мы нацелены на то чтобы иметь модули для большинства популярных библиотек.
Помогите нам в разработке, если вы используете фреймворк, которого нет в списке.

### Symfony2

Для интеграции Symfony2 вам не нужно устанавливать ни каких бандлов или менять конфигурцаию.
Просто подключите модуль Symfony2 в ваш тестовый набор. Если вы используете Doctrine2, не забудте подключить его тоже.

Пример для `functional.suite.yml`

```yaml
class_name: TestGuy
modules:
    enabled: [Symfony2, Doctrine2, TestHelper] 
```

По умолчнаию модуль будет искать ядро в директории `app`.

Модуль использует Symfony Profiler для предоставления дополнительной информации.

[Смотрите полную справку](http://codeception.com/docs/modules/Symfony2)

### Laravel 4

[Laravel](http://codeception.com/docs/modules/Laravel4) не имеет конфигурации и так же может быть легко настроен.

```yaml
class_name: TestGuy
modules:
    enabled: [Laravel4, TestHelper]
```

### Yii

Сам по себе Yii framework не имеет движка для функционального тестирования.
Таким образом Codeception первый и единственный фреймворк для функционального тестирования на Yii.
Для использования его с Yii включите модуль `Yii1` в файл конфигурации.

```yaml
class_name: TestGuy
modules:
    enabled: [Yii1, TestHelper]
```

Для того чтобы избежать подводных камней описаных ранее, Codeception предоставляет некоторые хуки поверх движка Yii.
Для его установки [следуйте шагам описаным в руководстве](http://codeception.com/docs/modules/Yii1).

### Zend Framework 2

Используйте модуль [ZF2](http://codeception.com/docs/modules/ZF2) для запуска функциональных тестов внутри Zend Framework 2.

```yaml
class_name: TestGuy
modules:
    enabled: [ZF2, TestHelper]
```

### Zend Framework 1.x

Модуль для Zend Framework значитичтельно заимствует функциональ класса ControllerTestCase, используемого для функциональных тестов с помощью PHPUnit. 
Он использует похожие подходы для загрузки и очистки. Для использования Zend Framework в ваших функциональных тестах, включите модуль ZF1.

Пример для `functional.suite.yml`

```yaml
class_name: TestGuy
modules:
    enabled: [ZF1, TestHelper] 
```

[Смотрите полную справку](http://codeception.com/docs/modules/ZF1)

### symfony

Этот модуль один из первых который был разработан для Codeception. Поэтому его дествия могут отличатся от действий используемых в других фреймворках.
Он предоставляет множество удобных операций, таких как логирование с помощью sfGuardAuth или валидация внутри теста.

Пример для `functional.suite.yml`

```yaml
class_name: TestGuy
modules:
    enabled: [Symfony1, TestHelper] 
```

[Смотрите полную справку](http://codeception.com/docs/modules/Symfony1)

## Интеграция с другими фреймворками

Codeception не предоставляет базового модуля для функционального тестирования потому, что есть множество деталей которые невозможно реализовать в таком варианте.
Мы уже обсудили распространенные подводные камни функционального тестирования. И не существует единого способа решить все эти проблемы для всех PHP приложений.
Так что, если вы не используете не один из фреймворков представленных выше, вы можете захотеть интегрировать фреймворк который используете в Codeception. Эта задача требует некоторого знания внутренностей Codeception и некоторого времени. Вероятно вам хватит использования только приемочных тестов, но любая помощь в расширении функциональности Codecaption будет оценена. Мы посмотрим что должно быть сделано для интеграции вашего фреймворка.

#### Использующеие HttpKernel

Если у вас есть фреймворк который исползует Symfony's `HttpKernel`, работа с COdeception не составит труда.
Вам нужно созать модуль для него и использовать его в вашем приложении.
У нас есть [руководство по интеграции](http://codeception.com/01-24-2013/connecting-php-frameworks-1.html).
Разработайте модуль, попробуйте и поделитесь с собществом.

#### Любые другие

Интеграция становится сложнее, если ваш фреймворк не использует компонент HttpKernel.
Самая сложная часть - это разрешение типичных проблем: управления памятью, и использования `headers` функций.
Codeception использует [BrowserKit](https://github.com/symfony/BrowserKit) взятый из компонентов Symfony Components для взаимодействия с приложеними в функциональных тестах. Этот компонент предоставляет все из распространенных дейтствий которые вы могли видеть в модулях: click, fillField, see, и т.д... Таким образом вам не нужно реализовывать данные методы в своем модуле. Для интеграции вы должны реализовать мост между BrowserKit и вашим приложением.

Начнем с написания класса помощника для реализации интеграции

```php
<?php
namespace Codeception\Module;
class SomeFrameworkHelper extends \Codeception\Util\Framework {
     
}
?>
```

Давайте исследуем [Исходный код Codeception](https://github.com/Codeception/Codeception).
Взгляните в файл `src/Util/Framework.php` который мы расширяем. Он реализует большинство распространенных дейтсвий для всех фреймворков.

Как вы можете видеть все дейтвия предоставляются обектом 'client'. Нам нужно создать client который подключается к фреймворку.
Client должен расширять модуль Symfony\BrowserKit\Client, примеры клиентов находятся в каталоге `src/Util/Connector`. 
Если фреймворк не предоставляет собственных компонентов для функционального тестирования вы можете попробовать использовать Universal коннектор. Или же взгляните как реализован Zend connector, и реализуйте свой собственный.

Решите ли вы использовать Universal connector или напишете свой собственный, вы можете включить его в свой модуль.

```php
<?php
namespace Codeception\Module;
class SomeFrameworkHelper extends \Codeception\Util\Framework {
     
    public function _initialize() {
        $this->client = new \Codeception\Util\Connector\Universal();
        // or any other connector you implement
        
        // we need specify path to index file
        $this->client->setIndex('public_html/index.php');
    }     
}
?>
```

Если вы включите данный помощник в ваш набор, он позволит взаимодействовать с вашими прилоежниями.
Вы можете расширить его возможности подключив внутренние функции фреймворка.
Важно выполнять очистку после каждого запуска теста.
Это может быть реализовано в _before и _after методах модуля помощника. Проверьте, что фреймворк не кеширует ни каких данных или конфигурации во время тестирования.

После того как вы сделаете модуль стабильным, поделитесь им с сообществом. Форкнуте репозиторий Codeception, добавьте ваш модуль и сделайте Pull Request.

Вот некоторые требования к модулям:

* Он должен легко конфигурироваться.
* Он должен иметь хорошую документацию.
* Он должен расширять базыове опреации используя возможности фреймворка.
* Желательно чтобы он мог выводить дополнительную отладочную инфомрацию.

Мы не требем включения модульных тестов т.к. не существует хорошего пути для написания подходящий юнит тестов для интеграции фреймворков.
Но вы можете продемонстрировать простое приложение использующее ваш фремворк и ваш модуль с Codeception.

## Заключение

Функциональные тесты отличная вещь, если вы используете мощный фреймворк. Используя данные тесты вы можете полуать доступ и управлять их внутренним состоянием.
Это сделает ваши тесты короче и быстрее. В случае, если вы не используете фреймворки, не имеет практического смысоа в написании функциональных тестов.
Если вы используете фреймворк которого нет в списке, напишите модуль и поделитесь с сообществом.
